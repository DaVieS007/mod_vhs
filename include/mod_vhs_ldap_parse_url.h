/** * @version $Id$ * @brief LDAP Parse URL : * Use the ldap url parsing routines to break up the LDAP  URL into * host and port. * Is out of set_field because it is very big stuff * @author Xavier Beaudouin <kiwi (at) oav (dot) net> * @param cmd structure of the invoked command - read Apache API Documentation * @param dummy a dummy * @param url the URL to parse * @return NULL or Error string */#ifndef mod_vhs_ldap_parse_url_H#define mod_vhs_ldap_parse_url_Hstatic const char *mod_vhs_ldap_parse_url(cmd_parms *cmd, void *dummy, const char *url){    int result;    apr_ldap_url_desc_t *urld;    apr_ldap_err_t	*ldap_result;    vhs_config_rec *vhr = (vhs_config_rec *) ap_get_module_config(cmd->server->module_config, &vhs_module);    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: `%s'",	         url);    result = apr_ldap_url_parse(cmd->pool, url, &(urld), &(ldap_result));    if (result != APR_SUCCESS) {	VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG, 0, cmd->server, "ldap url not parsed : %s.", ldap_result->reason);    	return ldap_result->reason;    }    vhr->ldap_url = apr_pstrdup(cmd->pool, url);    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: Host: %s", urld->lud_host);    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: Port: %d", urld->lud_port);    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: DN: %s", urld->lud_dn);    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: attrib: %s", urld->lud_attrs? urld->lud_attrs[0] : "(null)");    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: scope: %s",	         (urld->lud_scope == LDAP_SCOPE_SUBTREE? "subtree" :		 urld->lud_scope == LDAP_SCOPE_BASE? "base" :		 urld->lud_scope == LDAP_SCOPE_ONELEVEL? "onelevel" : "unknown"));    VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0,	         cmd->server, "ldap url parse: filter: %s", urld->lud_filter);    /* Set all the values, or at least some sane defaults */    if (vhr->ldap_host) {        char *p = apr_palloc(cmd->pool, strlen(vhr->ldap_host) + strlen(urld->lud_host) + 2);        strcpy(p, urld->lud_host);        strcat(p, " ");        strcat(p, vhr->ldap_host);        vhr->ldap_host = p;    }    else {        vhr->ldap_host = urld->lud_host? apr_pstrdup(cmd->pool, urld->lud_host) : "localhost";    }    vhr->ldap_basedn = urld->lud_dn? apr_pstrdup(cmd->pool, urld->lud_dn) : "";    vhr->ldap_scope = urld->lud_scope == LDAP_SCOPE_ONELEVEL ? LDAP_SCOPE_ONELEVEL : LDAP_SCOPE_SUBTREE;    if (urld->lud_filter) {        if (urld->lud_filter[0] == '(') {            /*             * Get rid of the surrounding parens; later on when generating the             * filter, they'll be put back.             */            vhr->ldap_filter = apr_pstrdup(cmd->pool, urld->lud_filter+1);            vhr->ldap_filter[strlen(vhr->ldap_filter)-1] = '\0';        }        else {            vhr->ldap_filter = apr_pstrdup(cmd->pool, urld->lud_filter);        }    }    else {        vhr->ldap_filter = "objectClass=apacheConfig";    }    /*     *  "ldaps" indicates secure ldap connections desired     */    if (strncasecmp(url, "ldaps", 5) == 0)    {        vhr->ldap_secure = 1;        vhr->ldap_port = urld->lud_port? urld->lud_port : LDAPS_PORT;        VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, cmd->server,                     "LDAP: using SSL connections");    }    else    {        vhr->ldap_secure = 0;        vhr->ldap_port = urld->lud_port? urld->lud_port : LDAP_PORT;        VH_AP_LOG_ERROR(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, 0, cmd->server,                     "LDAP: not using SSL connections");    }    vhr->ldap_have_url = 1;    return NULL;}#endif